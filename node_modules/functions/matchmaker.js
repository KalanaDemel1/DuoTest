var crypto = require('crypto');
var rand = require('csprng');
var mongoose = require('mongoose');
//var math = require('mathjs');
var order = require('functions/modelos');
var user = require('functions/models');




exports.matchmaker = function(pno,DestinationLat,DestinationLon,LocationLat,LocationLon,orderID,taxiID,feedback,callback) {

        var id = mongoose.Types.ObjectId();

        var order1 = new order({
            "_id": id,
            "pNo": pno,
            "DestinationLat": DestinationLat,
            "DestinationLon": DestinationLon,
            "LocationLat":LocationLat,
            "LocationLon":LocationLon,
            "orderID":orderID,
            "taxiID":taxiID,
			"Feedback":feedback
        });

        order.find({'orderID':orderID},function(err,orders){
		
		var Wa=0.5;
		var Wb=0.5;
		var previousUsers=[];
		var closestUsers=[];
		var closestUsersDistance=[];
		var loclatitude=[];
		var loclongitude=[];
		var newloclatitude=[];
		var newloclongitude=[];
		var deslatitude=[];
		var deslongitude=[];
		var feedback=[];
		var newFeedback=[];
		var closestCount=-1;
		var score=0;
		

        if(orders.length != 0){
		
			for(var i = 0; i < orders.length;i++){
			
				 previousUsers[i] = orders[i].pno;
				 loclatitude[i] = orders[i].LocationLat;
				 loclongitude[i] = orders[i].LocationLon;
				 deslatitude[i] = orders[i].LocationLat;
				 deslongitude[i] = orders[i].LocationLon;
				 feedback[i] = orders[i].feedback;
				
				
			}
            
            //callback({'response':"Match(s) found",'res':previousUsers});
			
			//GeoLocation consideration UNCOMMENT when actual data is implemented 
			//
			
			for(var i = 0; i < orders.length;i++){
				
				//Get locations upto 1.1km accuracy 
				var temploclatOther=math.floor(loclatitude[i] * 100) / 100;
				var temploclonOther=math.floor(loclatitude[i] * 100) / 100;
				var temploclat=math.floor(LocationLat * 100) / 100;
				var temploclon=math.floor(LocationLon * 100) / 100;
				
				if((temploclat.toString().trim() ===temploclatOther.toString().trim()) && (temploclon.toString().trim() ===temploclonOther.toString().trim()) ){
				
					closestUsers[closestCount++]=previousUsers[i];	
					newloclatitude[closestCount++]=loclatitude[i] ;
					newloclongitude[closestCount++]=loclatitude[i];		
					newFeedback[closestCount++]=feedback[i];		
				
				}
				
			}
			
			for(var i = 0; i < closestUsers.length;i++){
			
				  closestUsersDistance[i]=calcCrow(newloclatitude[i],newloclatitude[i],LocationLat,LocationLon);
				  
				
				
			}
			
			callback({'response':"Match(s) found",'list':closestUsers,'distance':closestUsersDistance,'feedback':newFeedback});
			
			


        }
        else {

            callback({'response':"No Matches",'res':false});

        }
    });
}

function calcCrow(lat1, lon1, lat2, lon2) 
    {
      var R = 6371; // km
      var dLat = toRad(lat2-lat1);
      var dLon = toRad(lon2-lon1);
      var lat1 = toRad(lat1);
      var lat2 = toRad(lat2);

      var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
      var d = R * c;
      return d;
    }

    // Converts numeric degrees to radians
    function toRad(Value) 
    {
        return Value * Math.PI / 180;
    }





